<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infrakit Explorer</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: #f8f9fa; color: #212529; margin: 0; padding: 2rem; }
        h1 { text-align: center; color: #343a40; }
        #search-box { display: block; width: 100%; max-width: 600px; margin: 2rem auto; padding: 1rem; font-size: 1.2rem; border-radius: 8px; border: 1px solid #ced4da; box-sizing: border-box; }
        #results { max-width: 800px; margin: 2rem auto; }
        .result-item { background-color: #fff; border: 1px solid #dee2e6; border-radius: 8px; padding: 1rem; margin-bottom: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .result-item h3 { margin: 0 0 0.5rem 0; }
        .result-item p { margin: 0.2rem 0; color: #6c757d; }
        .result-item code { background-color: #e9ecef; padding: 0.2rem 0.4rem; border-radius: 4px; }
        .expandable { cursor: pointer; color: #007bff; }
        .expandable:hover { text-decoration: underline; }
        .child-container { border-top: 1px solid #e9ecef; margin-top: 1rem; padding-top: 1rem; display: none; }
        .child-item { margin-left: 20px; padding: 0.5rem; border-left: 2px solid #e9ecef; }
    </style>
</head>
<body>
<h1>☁️ Infrakit Explorer</h1>
<input type="text" id="search-box" placeholder="Search for projects...">
<div id="results"></div>

<script>
    const searchBox = document.getElementById('search-box');
    const resultsDiv = document.getElementById('results');

    const performSearch = async () => {
        const query = searchBox.value;
        resultsDiv.innerHTML = (query.length > 0) ? '<p>Searching...</p>' : '';
        if (query.length < 2) return;

        try {
            const response = await fetch(`/api/search?q=${encodeURIComponent(query)}`);
            if (!response.ok) {
                resultsDiv.innerHTML = `<p>Error: ${await response.text()}</p>`;
                return;
            }
            const results = await response.json();
            resultsDiv.innerHTML = ''; // Clear previous results

            if (results && results.length > 0) {
                results.forEach(res => {
                    // We only want to display top-level items like projects and EC2 instances
                    if (res.service === 'project' || res.service === 'ec2') {
                        const item = document.createElement('div');
                        item.className = 'result-item';
                        item.innerHTML = `
                            <h3 class="expandable" data-id="${res.id}" data-type="${res.service}">${res.name}</h3>
                            <p><strong>ID:</strong> <code>${res.id}</code> | <strong>Service:</strong> ${res.service}</p>
                            <div class="child-container" id="children-${res.id}" style="display: none;"></div>
                        `;
                        resultsDiv.appendChild(item);
                    }
                });
            } else {
                resultsDiv.innerHTML = '<p>No results found.</p>';
            }
        } catch (error) {
            resultsDiv.innerHTML = `<p>Error fetching results. Is the server running?</p>`;
        }
    };

    const fetchAndDisplayChildren = async (parentId, parentType, container) => {
        if (container.dataset.loaded === 'true') {
            container.style.display = container.style.display === 'none' ? 'block' : 'none';
            return;
        }
        if (parentType !== 'project') { // Only projects are expandable for now
            container.innerHTML = '<p>No further details available.</p>';
            container.style.display = 'block';
            container.dataset.loaded = 'true';
            return;
        }

        container.innerHTML = '<p>Loading details...</p>';
        container.style.display = 'block';

        try {
            const response = await fetch(`/api/resources?parent=${encodeURIComponent(parentId)}`);
            const children = await response.json();
            container.innerHTML = '';
            container.dataset.loaded = 'true';

            // Render VPCs and their subnets
            if (children.vpc && children.vpc.length > 0) {
                children.vpc.forEach(vpc => {
                    let subnetsHTML = '';
                    if (children.subnet) {
                        children.subnet.filter(s => s.attributes.vpc.endsWith(vpc.id)).forEach(subnet => {
                            subnetsHTML += `<div class="child-item">↳ <strong>Subnet:</strong> ${subnet.name} (<code>${subnet.attributes.cidr_range}</code>)</div>`;
                        });
                    }
                    container.innerHTML += `<div class="child-item"><strong>VPC:</strong> ${vpc.name}${subnetsHTML}</div>`;
                });
            }
            // Render Firewall rules
            if (children.firewall && children.firewall.length > 0) {
                container.innerHTML += `<div class="child-item"><strong>Firewall Rules:</strong> (${children.firewall.length} rules found)</div>`;
            }

        } catch(e) {
            container.innerHTML = '<p>Could not load details.</p>';
        }
    };

    searchBox.addEventListener('keyup', performSearch);

    // Use event delegation for click handlers on dynamic content
    resultsDiv.addEventListener('click', (event) => {
        const target = event.target;
        if (target && target.classList.contains('expandable')) {
            const id = target.dataset.id;
            const type = target.dataset.type;
            const container = document.getElementById(`children-${id}`);
            fetchAndDisplayChildren(id, type, container);
        }
    });
</script>
</body>
</html>